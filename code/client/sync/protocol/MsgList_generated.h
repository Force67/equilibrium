// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MSGLIST_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_MSGLIST_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

#include "Handshake_generated.h"

namespace protocol
{
  struct MessageRoot;
  struct MessageRootBuilder;

  enum Data {
	Data_NONE = 0,
	Data_Handshake = 1,
	Data_MIN = Data_NONE,
	Data_MAX = Data_Handshake
  };

  inline const Data (&EnumValuesData())[2]
  {
	static const Data values[] = {
	  Data_NONE,
	  Data_Handshake
	};
	return values;
  }

  inline const char *const *EnumNamesData()
  {
	static const char *const names[3] = {
	  "NONE",
	  "Handshake",
	  nullptr
	};
	return names;
  }

  inline const char *EnumNameData(Data e)
  {
	if(flatbuffers::IsOutRange(e, Data_NONE, Data_Handshake))
	  return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesData()[index];
  }

  template <typename T>
  struct DataTraits {
	static const Data enum_value = Data_NONE;
  };

  template <>
  struct DataTraits<protocol::Handshake> {
	static const Data enum_value = Data_Handshake;
  };

  bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
  bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

  struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef MessageRootBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
	  VT_DATA_TYPE = 4,
	  VT_DATA = 6
	};
	protocol::Data data_type() const
	{
	  return static_cast<protocol::Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
	}
	const void *data() const
	{
	  return GetPointer<const void *>(VT_DATA);
	}
	template <typename T>
	const T *data_as() const;
	const protocol::Handshake *data_as_Handshake() const
	{
	  return data_type() == protocol::Data_Handshake ? static_cast<const protocol::Handshake *>(data()) : nullptr;
	}
	bool Verify(flatbuffers::Verifier &verifier) const
	{
	  return VerifyTableStart(verifier) &&
	         VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
	         VerifyOffset(verifier, VT_DATA) &&
	         VerifyData(verifier, data(), data_type()) &&
	         verifier.EndTable();
	}
  };

  template <>
  inline const protocol::Handshake *MessageRoot::data_as<protocol::Handshake>() const
  {
	return data_as_Handshake();
  }

  struct MessageRootBuilder {
	typedef MessageRoot Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_data_type(protocol::Data data_type)
	{
	  fbb_.AddElement<uint8_t>(MessageRoot::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
	}
	void add_data(flatbuffers::Offset<void> data)
	{
	  fbb_.AddOffset(MessageRoot::VT_DATA, data);
	}
	explicit MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
	    fbb_(_fbb)
	{
	  start_ = fbb_.StartTable();
	}
	MessageRootBuilder &operator=(const MessageRootBuilder &);
	flatbuffers::Offset<MessageRoot> Finish()
	{
	  const auto end = fbb_.EndTable(start_);
	  auto o = flatbuffers::Offset<MessageRoot>(end);
	  return o;
	}
  };

  inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(
      flatbuffers::FlatBufferBuilder &_fbb,
      protocol::Data data_type = protocol::Data_NONE,
      flatbuffers::Offset<void> data = 0)
  {
	MessageRootBuilder builder_(_fbb);
	builder_.add_data(data);
	builder_.add_data_type(data_type);
	return builder_.Finish();
  }

  inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type)
  {
	switch(type) {
	case Data_NONE: {
	  return true;
	}
	case Data_Handshake: {
	  auto ptr = reinterpret_cast<const protocol::Handshake *>(obj);
	  return verifier.VerifyTable(ptr);
	}
	default: return true;
	}
  }

  inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types)
  {
	if(!values || !types)
	  return !values && !types;
	if(values->size() != types->size())
	  return false;
	for(flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
	  if(!VerifyData(
	         verifier, values->Get(i), types->GetEnum<Data>(i))) {
		return false;
	  }
	}
	return true;
  }

  inline const protocol::MessageRoot *GetMessageRoot(const void *buf)
  {
	return flatbuffers::GetRoot<protocol::MessageRoot>(buf);
  }

  inline const protocol::MessageRoot *GetSizePrefixedMessageRoot(const void *buf)
  {
	return flatbuffers::GetSizePrefixedRoot<protocol::MessageRoot>(buf);
  }

  inline bool VerifyMessageRootBuffer(
      flatbuffers::Verifier &verifier)
  {
	return verifier.VerifyBuffer<protocol::MessageRoot>(nullptr);
  }

  inline bool VerifySizePrefixedMessageRootBuffer(
      flatbuffers::Verifier &verifier)
  {
	return verifier.VerifySizePrefixedBuffer<protocol::MessageRoot>(nullptr);
  }

  inline void FinishMessageRootBuffer(
      flatbuffers::FlatBufferBuilder &fbb,
      flatbuffers::Offset<protocol::MessageRoot> root)
  {
	fbb.Finish(root);
  }

  inline void FinishSizePrefixedMessageRootBuffer(
      flatbuffers::FlatBufferBuilder &fbb,
      flatbuffers::Offset<protocol::MessageRoot> root)
  {
	fbb.FinishSizePrefixed(root);
  }

} // namespace protocol

#endif // FLATBUFFERS_GENERATED_MSGLIST_PROTOCOL_H_
