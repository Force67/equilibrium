// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_HANDSHAKE_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_HANDSHAKE_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace protocol {

  struct HandshakeRequest;
  struct HandshakeRequestBuilder;

  struct HandshakeAck;
  struct HandshakeAckBuilder;

  enum UserPermissions {
	UserPermissions_Guest = 1,
	UserPermissions_Reporter = 2,
	UserPermissions_Developer = 4,
	UserPermissions_Master = 8,
	UserPermissions_NONE = 0,
	UserPermissions_ANY = 15
  };

  inline const UserPermissions (&EnumValuesUserPermissions())[4]
  {
	static const UserPermissions values[] = {
	  UserPermissions_Guest,
	  UserPermissions_Reporter,
	  UserPermissions_Developer,
	  UserPermissions_Master
	};
	return values;
  }

  inline const char *const *EnumNamesUserPermissions()
  {
	static const char *const names[9] = {
	  "Guest",
	  "Reporter",
	  "",
	  "Developer",
	  "",
	  "",
	  "",
	  "Master",
	  nullptr
	};
	return names;
  }

  inline const char *EnumNameUserPermissions(UserPermissions e)
  {
	if(flatbuffers::IsOutRange(e, UserPermissions_Guest, UserPermissions_Master))
	  return "";
	const size_t index = static_cast<size_t>(e) - static_cast<size_t>(UserPermissions_Guest);
	return EnumNamesUserPermissions()[index];
  }

  struct HandshakeRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef HandshakeRequestBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
	  VT_PROTOCOLVERSION = 4,
	  VT_TOKEN = 6,
	  VT_GUID = 8,
	  VT_NAME = 10,
	  VT_PASSWORD = 12
	};
	uint16_t protocolVersion() const
	{
	  return GetField<uint16_t>(VT_PROTOCOLVERSION, 0);
	}
	const flatbuffers::String *token() const
	{
	  return GetPointer<const flatbuffers::String *>(VT_TOKEN);
	}
	const flatbuffers::String *guid() const
	{
	  return GetPointer<const flatbuffers::String *>(VT_GUID);
	}
	const flatbuffers::String *name() const
	{
	  return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	const flatbuffers::String *password() const
	{
	  return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
	}
	bool Verify(flatbuffers::Verifier &verifier) const
	{
	  return VerifyTableStart(verifier) &&
	         VerifyField<uint16_t>(verifier, VT_PROTOCOLVERSION) &&
	         VerifyOffset(verifier, VT_TOKEN) &&
	         verifier.VerifyString(token()) &&
	         VerifyOffset(verifier, VT_GUID) &&
	         verifier.VerifyString(guid()) &&
	         VerifyOffset(verifier, VT_NAME) &&
	         verifier.VerifyString(name()) &&
	         VerifyOffset(verifier, VT_PASSWORD) &&
	         verifier.VerifyString(password()) &&
	         verifier.EndTable();
	}
  };

  struct HandshakeRequestBuilder {
	typedef HandshakeRequest Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_protocolVersion(uint16_t protocolVersion)
	{
	  fbb_.AddElement<uint16_t>(HandshakeRequest::VT_PROTOCOLVERSION, protocolVersion, 0);
	}
	void add_token(flatbuffers::Offset<flatbuffers::String> token)
	{
	  fbb_.AddOffset(HandshakeRequest::VT_TOKEN, token);
	}
	void add_guid(flatbuffers::Offset<flatbuffers::String> guid)
	{
	  fbb_.AddOffset(HandshakeRequest::VT_GUID, guid);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name)
	{
	  fbb_.AddOffset(HandshakeRequest::VT_NAME, name);
	}
	void add_password(flatbuffers::Offset<flatbuffers::String> password)
	{
	  fbb_.AddOffset(HandshakeRequest::VT_PASSWORD, password);
	}
	explicit HandshakeRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
	    fbb_(_fbb)
	{
	  start_ = fbb_.StartTable();
	}
	HandshakeRequestBuilder &operator=(const HandshakeRequestBuilder &);
	flatbuffers::Offset<HandshakeRequest> Finish()
	{
	  const auto end = fbb_.EndTable(start_);
	  auto o = flatbuffers::Offset<HandshakeRequest>(end);
	  return o;
	}
  };

  inline flatbuffers::Offset<HandshakeRequest> CreateHandshakeRequest(
      flatbuffers::FlatBufferBuilder &_fbb,
      uint16_t protocolVersion = 0,
      flatbuffers::Offset<flatbuffers::String> token = 0,
      flatbuffers::Offset<flatbuffers::String> guid = 0,
      flatbuffers::Offset<flatbuffers::String> name = 0,
      flatbuffers::Offset<flatbuffers::String> password = 0)
  {
	HandshakeRequestBuilder builder_(_fbb);
	builder_.add_password(password);
	builder_.add_name(name);
	builder_.add_guid(guid);
	builder_.add_token(token);
	builder_.add_protocolVersion(protocolVersion);
	return builder_.Finish();
  }

  inline flatbuffers::Offset<HandshakeRequest> CreateHandshakeRequestDirect(
      flatbuffers::FlatBufferBuilder &_fbb,
      uint16_t protocolVersion = 0,
      const char *token = nullptr,
      const char *guid = nullptr,
      const char *name = nullptr,
      const char *password = nullptr)
  {
	auto token__ = token ? _fbb.CreateString(token) : 0;
	auto guid__ = guid ? _fbb.CreateString(guid) : 0;
	auto name__ = name ? _fbb.CreateString(name) : 0;
	auto password__ = password ? _fbb.CreateString(password) : 0;
	return protocol::CreateHandshakeRequest(
	    _fbb,
	    protocolVersion,
	    token__,
	    guid__,
	    name__,
	    password__);
  }

  struct HandshakeAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef HandshakeAckBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
	  VT_PERMS = 4,
	  VT_USERINDEX = 6,
	  VT_NUMUSERS = 8
	};
	protocol::UserPermissions perms() const
	{
	  return static_cast<protocol::UserPermissions>(GetField<uint8_t>(VT_PERMS, 0));
	}
	uint32_t userIndex() const
	{
	  return GetField<uint32_t>(VT_USERINDEX, 0);
	}
	int32_t numUsers() const
	{
	  return GetField<int32_t>(VT_NUMUSERS, 0);
	}
	bool Verify(flatbuffers::Verifier &verifier) const
	{
	  return VerifyTableStart(verifier) &&
	         VerifyField<uint8_t>(verifier, VT_PERMS) &&
	         VerifyField<uint32_t>(verifier, VT_USERINDEX) &&
	         VerifyField<int32_t>(verifier, VT_NUMUSERS) &&
	         verifier.EndTable();
	}
  };

  struct HandshakeAckBuilder {
	typedef HandshakeAck Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_perms(protocol::UserPermissions perms)
	{
	  fbb_.AddElement<uint8_t>(HandshakeAck::VT_PERMS, static_cast<uint8_t>(perms), 0);
	}
	void add_userIndex(uint32_t userIndex)
	{
	  fbb_.AddElement<uint32_t>(HandshakeAck::VT_USERINDEX, userIndex, 0);
	}
	void add_numUsers(int32_t numUsers)
	{
	  fbb_.AddElement<int32_t>(HandshakeAck::VT_NUMUSERS, numUsers, 0);
	}
	explicit HandshakeAckBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
	    fbb_(_fbb)
	{
	  start_ = fbb_.StartTable();
	}
	HandshakeAckBuilder &operator=(const HandshakeAckBuilder &);
	flatbuffers::Offset<HandshakeAck> Finish()
	{
	  const auto end = fbb_.EndTable(start_);
	  auto o = flatbuffers::Offset<HandshakeAck>(end);
	  return o;
	}
  };

  inline flatbuffers::Offset<HandshakeAck> CreateHandshakeAck(
      flatbuffers::FlatBufferBuilder &_fbb,
      protocol::UserPermissions perms = static_cast<protocol::UserPermissions>(0),
      uint32_t userIndex = 0,
      int32_t numUsers = 0)
  {
	HandshakeAckBuilder builder_(_fbb);
	builder_.add_numUsers(numUsers);
	builder_.add_userIndex(userIndex);
	builder_.add_perms(perms);
	return builder_.Finish();
  }

} // namespace protocol

#endif // FLATBUFFERS_GENERATED_HANDSHAKE_PROTOCOL_H_
