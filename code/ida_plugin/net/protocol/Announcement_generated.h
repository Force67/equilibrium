// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ANNOUNCEMENT_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_ANNOUNCEMENT_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace protocol {

  struct Announcement;
  struct AnnouncementBuilder;

  enum AnnounceType {
	AnnounceType_FirstJoin = 0,
	AnnounceType_Joined = 1,
	AnnounceType_Disconnect = 2,
	AnnounceType_MIN = AnnounceType_FirstJoin,
	AnnounceType_MAX = AnnounceType_Disconnect
  };

  inline const AnnounceType (&EnumValuesAnnounceType())[3]
  {
	static const AnnounceType values[] = {
	  AnnounceType_FirstJoin,
	  AnnounceType_Joined,
	  AnnounceType_Disconnect
	};
	return values;
  }

  inline const char *const *EnumNamesAnnounceType()
  {
	static const char *const names[4] = {
	  "FirstJoin",
	  "Joined",
	  "Disconnect",
	  nullptr
	};
	return names;
  }

  inline const char *EnumNameAnnounceType(AnnounceType e)
  {
	if(flatbuffers::IsOutRange(e, AnnounceType_FirstJoin, AnnounceType_Disconnect))
	  return "";
	const size_t index = static_cast<size_t>(e);
	return EnumNamesAnnounceType()[index];
  }

  struct Announcement FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef AnnouncementBuilder Builder;
	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
	  VT_TYPE = 4,
	  VT_NAME = 6
	};
	protocol::AnnounceType type() const
	{
	  return static_cast<protocol::AnnounceType>(GetField<int8_t>(VT_TYPE, 0));
	}
	const flatbuffers::String *name() const
	{
	  return GetPointer<const flatbuffers::String *>(VT_NAME);
	}
	bool Verify(flatbuffers::Verifier &verifier) const
	{
	  return VerifyTableStart(verifier) &&
	         VerifyField<int8_t>(verifier, VT_TYPE) &&
	         VerifyOffset(verifier, VT_NAME) &&
	         verifier.VerifyString(name()) &&
	         verifier.EndTable();
	}
  };

  struct AnnouncementBuilder {
	typedef Announcement Table;
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;
	void add_type(protocol::AnnounceType type)
	{
	  fbb_.AddElement<int8_t>(Announcement::VT_TYPE, static_cast<int8_t>(type), 0);
	}
	void add_name(flatbuffers::Offset<flatbuffers::String> name)
	{
	  fbb_.AddOffset(Announcement::VT_NAME, name);
	}
	explicit AnnouncementBuilder(flatbuffers::FlatBufferBuilder &_fbb) :
	    fbb_(_fbb)
	{
	  start_ = fbb_.StartTable();
	}
	AnnouncementBuilder &operator=(const AnnouncementBuilder &);
	flatbuffers::Offset<Announcement> Finish()
	{
	  const auto end = fbb_.EndTable(start_);
	  auto o = flatbuffers::Offset<Announcement>(end);
	  return o;
	}
  };

  inline flatbuffers::Offset<Announcement> CreateAnnouncement(
      flatbuffers::FlatBufferBuilder &_fbb,
      protocol::AnnounceType type = protocol::AnnounceType_FirstJoin,
      flatbuffers::Offset<flatbuffers::String> name = 0)
  {
	AnnouncementBuilder builder_(_fbb);
	builder_.add_name(name);
	builder_.add_type(type);
	return builder_.Finish();
  }

  inline flatbuffers::Offset<Announcement> CreateAnnouncementDirect(
      flatbuffers::FlatBufferBuilder &_fbb,
      protocol::AnnounceType type = protocol::AnnounceType_FirstJoin,
      const char *name = nullptr)
  {
	auto name__ = name ? _fbb.CreateString(name) : 0;
	return protocol::CreateAnnouncement(
	    _fbb,
	    type,
	    name__);
  }

} // namespace protocol

#endif // FLATBUFFERS_GENERATED_ANNOUNCEMENT_PROTOCOL_H_
